# 算法与数据结构

> 算法实现参考课本 `<<数据结构与程序设计 --- c++ 语言描述>> Robert L.Kruse Alexander J.Ryba` 由于模板类不能将类分为 .h 头文件和 .cpp 文件，分开实现，只能在 .h 文件中实现，所以本项目内容基本都在 .h 中实现（或许是笔者才疏学浅，有分离的解决方案希望能告知笔者，可以提交 issue :smile: ）

## 树
* 二叉查找树 binary_search_tree.h
* B树 b-tree.h
* 红黑树 red-black-tree.h

## Binary Tree

#### 概念

* 二叉树的每个结点至多只有二棵子树(不存在度大于2的结点)
* 二叉树的子树有左右之分，次序不能颠倒。(并且默认的前中后序遍历左子树在右子树前面)
* binary search tree 左子树值小于右子树
* binary tree 的 key 唯一

#### 树和二叉树的2个主要差别：
* 树中结点的最大度数没有限制，而二叉树结点的最大度数为2；
* 树的结点无左、右之分，而二叉树的结点有左、右之分。……

#### 树的度和结点数的关系

1、非空二叉树的第n层上至多有2^(n-1)个元素(叶子)。
2、深度为h的二叉树至多有2^h-1个结点。


二叉树总节点数目为N，有 N=N0+N1+N2---(公式1)；
N+1=N1+2*N2(公式2)；
n0 = n2 +1
二叉树度数总和为0*N0+1*N1+2*N2 ；

## Binary Search Tree
#### 二叉查找树
#### tips

* 二叉查找树遍历的算法与快排极其相似 O(nlogn)
二叉查找树适合一个一个节点进入排序，快排适合一个list进行排序

## B-Tree
#### 平衡多路查找树

#### tips
* B 代表它的 度（此处的度是 order，翻译并不统一，依据代码来理解），代码中的模板 order，也就是一个节点可以有多少个 branch，以及 order-1 个数据
* 节点内部查找是线性查找（从第一个遍历到最后一个），可以优化
* split_node，分离后的 current 节点的 data 中分走的数据并没有被删除，只是减少了 count 的值，combine 删除父节点之后旧的 branch 也没有删除，也是通过减少 count 最终约束了 branch 的边界

#### 实际应用
* mysql 的索引使用 B+ 树，一种 data branch 长度相同的 B 树变种，只有叶节点存放数据，其余节点用来索引

## Red-Black Tree
#### 红黑树
#### 定义
* 每个节点都是红色或者黑色的
* 默认root节点和leaf节点是黑色（leaf节点是null但是颜色是黑色）
* 红节点的父节点一定是黑色
* 从根节点到任何叶子节点都会走过相同的黑节点数（黑高度不计算节点本身和红节点）

#### tips
* n 个节点的红黑树高度是 2logn，检索的时间复杂度是 O(logn)
* 红色节点向上合并就变成了 B-Tree
* 递归时只考虑三代，通过重新上色和旋转（只旋转一次或两次）来实现，当前三代满足定义之后，如果整体还不满足则把问题往上传


#### 实际应用
* epoll 的内核使用数据结构红黑树


## 图
* 深度优先
* 广度优先
* 最小生成树 `将一个图通过切割变成两个子图，被切的边里最小的属于最小生成树的边`
* Dijkstra 最短路径 `类似于最小生成树，网易公开课 MIT 的算法导论里使用 priority queue (优先队列)的结构和 min heap (最小堆)，课本里用的普通数组，但是算法都是一样的`

> 所有的实现都在 main.cpp 里有使用 demo 可以参考，通过单步调试 demo 可以较好的理解算法的实现过程，图的实现待完成